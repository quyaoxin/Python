# 正则表达式

## re模块分为三种:
- match:从行头开始匹配,如果行首没有的话则返回一个none   
- search:匹配整个字符串,如果匹配到的话,则返回第一个匹配的元素  
- findall:匹配整个字符串,返回所有匹配得到的结果,并把他们作为一个列表返回
## 关于re模块格式
- **re.match/search/findall(pattern,string,flags=0);**
- 其中:   
- pattern:匹配的正则表达式  
- string:要匹配的字符串   
- flags:标识符,用于控制正则表达式的匹配方式
## flags标识符的各种分类
- **re.I**:使匹配对大小写不敏感  
- **re.L**:做本地化识别匹配(是用来匹配不同的语言的编程提供帮助,因为\w只匹配字符类型[A-Za-z];它并不会匹配"é" 或 "ç"(法文),但是如果你的系统配置适当且本地化设置为法语,那么内部的C函数将告诉程序"é"也应该是一个字母.当在编译正则表达式的时候使用LOCALE标志会得到这些C函数来处理\w后的编译对象.                                                                           
- **re.M**:多行匹配,影响^和$
- **re.S**:使匹配包括换行符在内的所有字符  
- **re.U**:根据Unicode字符集解析字符,影响\w,\W,\b,\B  
- **re.X**:根据给予我们功能灵活的格式以便更好的理解正则表达式.当该标志被指定时,在RE字符串中的空白字符将会被忽略,除非该空白字符在字符串类中或者在反斜杠之后;这可以让你更加清晰地组织和缩进RE.它也可以容许你将注释写入RE,这些注释会被引擎忽略;注释用"#"号来标识,不过该符号不能在字符串或者反斜杠之后.  
##正则表达式字符的规则
- **.** : 匹配除换行符以外的任意字符,当flags被指定为re.S时可以匹配包含换行符以内的所有字符,如果没有指定并且还想匹配所有字符,则使用[.\n]的方法  
- **[ ]**  里面是字符的集合,匹配[ ]里面任意的一个字符
- **[0123456789]** 匹配任意一个数字字符
- **[0-9]** 匹配任意一个数字字符
-  **[a-z]** 匹配任意一个小写英文字母字符
-  **[A-Z]** 匹配任意一个大写英文字母字符
-  **[a-zA-Z]**匹配任意一个字母字符