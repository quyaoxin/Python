# 正则表达式

## re模块分为三种:
- match:从行头开始匹配,如果行首没有的话则返回一个none   
- search:匹配整个字符串,如果匹配到的话,则返回第一个匹配的元素  
- findall:匹配整个字符串,返回所有匹配得到的结果,并把他们作为一个列表返回
## 关于re模块格式
- **re.match/search/findall(pattern,string,flags=0);**
- 其中:   
- pattern:匹配的正则表达式  
- string:要匹配的字符串   
- flags:标识符,用于控制正则表达式的匹配方式
## flags标识符的各种分类
- **re.I**:使匹配对大小写不敏感  
- **re.L**:做本地化识别匹配(是用来匹配不同的语言的编程提供帮助,因为\w只匹配字符类型[A-Za-z];它并不会匹配"é" 或 "ç"(法文),但是如果你的系统配置适当且本地化设置为法语,那么内部的C函数将告诉程序"é"也应该是一个字母.当在编译正则表达式的时候使用LOCALE标志会得到这些C函数来处理\w后的编译对象.                                                                           
- **re.M**:多行匹配,影响^和$
- **re.S**:使匹配包括换行符在内的所有字符  
- **re.U**:根据Unicode字符集解析字符,影响\w,\W,\b,\B  
- **re.X**:根据给予我们功能灵活的格式以便更好的理解正则表达式.当该标志被指定时,在RE字符串中的空白字符将会被忽略,除非该空白字符在字符串类中或者在反斜杠之后;这可以让你更加清晰地组织和缩进RE.它也可以容许你将注释写入RE,这些注释会被引擎忽略;注释用"#"号来标识,不过该符号不能在字符串或者反斜杠之后.  
##正则表达式字符的规则
- **.** : 匹配除换行符以外的任意字符,当flags被指定为re.S时可以匹配包含换行符以内的所有字符,如果没有指定并且还想匹配所有字符,则使用[.\n]的方法  
- **[ ]**:里面是字符的集合,匹配[ ]里面任意的一个字符
- **[0123456789]**:匹配任意一个数字字符
- **[0-9]**: 匹配任意一个数字字符
-  **[a-z]** :匹配任意一个小写英文字母字符
-  **[A-Z]** :匹配任意一个大写英文字母字符
-  **[a-zA-Z]**:匹配任意一个字母字符  
-  **[a-zA-Z0-9]**:匹配任意一个数字或字母
-  **[^sunck]**: [ ]里的^为脱字符,表示非,匹配不在[ ]里的任意一个字符.  

- **\d**:匹配任意一个数字字符 [0-9]  
- **\D**:匹配任意一个非数字符  [^0-9]
- **\w** :匹配字母、下划线、数字   [0-9a-zA-z_]
- **\W** : 匹配非字母、下划线、数字   [^0-9a-zA-z_]
- **\s**  :匹配空白符(空格、换页、换行、回车、制表等)  [ \f\n\r\t]
- **\S**: 匹配非空白符    [^ \f\n\r\t]  
##锚字符  
- **^** :行首匹配,和[ ]中的^并不是一个意思
- **$**:行尾匹配  
##边界字符(边界字符前必须加上r转义字符)
- **\A**: 匹配字符串的开始,和^的区别是\A只匹配整个字符的开头,即使在re.M模式下,也不会匹配其它的行首  
- **\Z**: 匹配字符串结尾,和$的区别是\Z只匹配整个字符的结尾,即使在re.M模式下,也不会匹配其它的结尾  
- **\b** : 匹配一个单词的边界,指单词和空格的位置  
- **\B** :匹配非单词边界
###匹配多个字符
####(以下使用的x,y,z均为假设的普通字符,n丶m表示一个数字,他们不是正则表达式是元字符)
- **(x,y,z)** :匹配括号内的xyz(作为一个整体去匹配)
-  **x?** :匹配0个或1个x,非贪婪匹配
-  **x*** :匹配0个或任意多个x
-  **x+** :匹配至少一个x
-  **x{n}** :匹配确定n个x,n是非负整数
-  **x{n, }** :匹配至少n个x
-  **x{n,m}** : 匹配至少n个,至多m个x
-  **x|y** : |表示或,匹配x或y  
##finditer函数
- **格式:**finditer(pattern,string,flags=0)  

- **作用:**类似findall,但是返回的是一个迭代器  

- **区别:**findall返回的是所有匹配的字符串,并且存为一个列表,如果数据过多的话,占用的内存也会变多.而finditer返回的是一个迭代器,只占用很少的内存,可以通过next迭代
##字符串的替换和修改
- sub(pattern,repl,string,count=0,flags=0)
- subn(pattern,repl,string,count=0,flags=0)   
- **作用**：在目标字符串string中查找匹配的pattern模式字符，在把它们替换成指定的repl字符串，可以指定最多替换count次，否则替换所有的字符  
- **参数**：  
   pattern：正则表达式  
   repl：指定用来替换的字符串  
   string：目标字符串  
   count：最多替换次数  
   flags：指示标识  
##正则中的分组
- 正则除了可以判断是否匹配之外,还有提取字符串的功能,用( )表示的就是要提取的分组
- 实例为:  
import re  
a = "123abc456"  
print re.search("([0-9]\*)([a-z]\*)([0-9]\*)",a).group(0)   >123abc456,返回整体  
print re.search("([0-9]\*)([a-z]\*)([0-9]\*)",a).group(1)   >123  
print re.search("([0-9]\*)([a-z]\*)([0-9]\*)",a).group(2)  >abc  
print re.search("([0-9]\*)([a-z]\*)([0-9]\*)",a).group(3)   >456  
##贪婪匹配
**系统在正则匹配的时候默认的是贪婪匹配**  
**贪婪匹配:**正则表达式一般趋向于最大长度的匹配,也就是所谓的贪婪匹配.  
例如:string str="abcaxc";  
	 pattern p ="ab\*c";  
贪婪匹配匹配到的结果就是:abcaxc  
而非贪婪匹配匹配到的结果就是:abc  
**非贪婪匹配的方法是:**在量词的后面直接加上一个问号?就是非贪婪模式(详情可见上述的"匹配多个字符串")